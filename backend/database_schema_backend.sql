-- ============================================================================
-- CIVICAGENT COMPLETE DATABASE SCHEMA
-- Combines frontend and backend requirements
-- ============================================================================

-- ============================================================================
-- CRITICAL: DROP EXISTING TABLES TO FIX SCHEMA CACHE ERRORS
-- This ensures the schema is rebuilt with correct columns
-- ============================================================================

DROP TABLE IF EXISTS public.complaint_actions CASCADE;
DROP TABLE IF EXISTS public.feedback CASCADE;
DROP TABLE IF EXISTS public.user_roles CASCADE;
DROP TABLE IF EXISTS public.complaints CASCADE;
-- Keep departments table if it exists

-- ============================================================================
-- SECTION 1: CUSTOM TYPES
-- ============================================================================

-- Role and permission enums (use DO block to avoid "already exists" errors)
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'app_role') THEN
    CREATE TYPE public.app_role AS ENUM ('admin', 'member');
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'app_permission') THEN
    CREATE TYPE public.app_permission AS ENUM ('complaints.delete', 'admin.access');
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'complaint_status') THEN
    CREATE TYPE public.complaint_status AS ENUM (
      'PROCESSING',
      'REPORTED', 
      'IN_PROGRESS',
      'ESCALATED',
      'RESOLVED',
      'REJECTED'
    );
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'action_type') THEN
    CREATE TYPE public.action_type AS ENUM (
      'submitted',
      'ai_analysis_complete',
      'email_sent',
      'follow_up_sent',
      'escalated',
      'resolved',
      'rejected',
      'status_changed',
      'sla_missed'
    );
  END IF;
END $$;

-- ============================================================================
-- SECTION 2: DEPARTMENTS TABLE
-- ============================================================================

create table if not exists public.departments (
  id bigint generated by default as identity primary key,
  name text not null,
  contact_email text not null,
  escalation_email text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  constraint departments_name_unique unique (name)
);

-- Enable RLS on departments table
ALTER TABLE public.departments ENABLE ROW LEVEL SECURITY;

-- Insert default departments (using DO block to prevent duplicate errors)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM public.departments WHERE name = 'Public Works') THEN
    INSERT INTO public.departments (name, contact_email, escalation_email) VALUES
      ('Public Works', 'publicworks@city.gov', 'pw.supervisor@city.gov'),
      ('Sanitation', 'sanitation@city.gov', 'sanitation.chief@city.gov'),
      ('Water & Sewage', 'water@city.gov', 'water.manager@city.gov'),
      ('Electricity', 'power@city.gov', 'power.emergency@city.gov'),
      ('Parks & Recreation', 'parks@city.gov', 'parks.director@city.gov'),
      ('Traffic & Roads', 'traffic@city.gov', 'traffic.superintendent@city.gov');
  END IF;
END $$;

-- ============================================================================
-- SECTION 3: COMPLAINTS TABLE (UNIFIED)
-- ============================================================================

create table if not exists public.complaints (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  
  -- Location data
  location geography(Point) not null,
  latitude double precision,
  longitude double precision,
  landmark text,
  
  -- User-provided data
  image_url text not null,
  user_description text,
  category text, -- User-selected category (optional)
  
  -- AI-generated data (from Vision Model)
  ai_detected_category text,
  ai_confidence integer, -- 0-100
  ai_report text, -- Full structured report from vision model
  
  -- AI-reasoned data (from Reasoning Agent)
  ai_generated_summary text, -- Professional summary for officials
  official_summary text, -- Alias for ai_generated_summary
  assigned_department_id bigint references public.departments on delete set null,
  
  -- SLA and status tracking
  sla_hours smallint, -- Determined by AI based on category
  sla_deadline timestamp with time zone,
  status public.complaint_status default 'PROCESSING'::public.complaint_status not null,
  
  -- User feedback (after resolution)
  user_rating integer check (user_rating >= 1 and user_rating <= 5),
  user_feedback text,
  
  -- Metadata
  resolved_at timestamp with time zone,
  resolution_notes text
);

-- Enable RLS
alter table public.complaints enable row level security;

-- Create indexes for performance
create index if not exists idx_complaints_user_id on public.complaints(user_id);
create index if not exists idx_complaints_status on public.complaints(status);
create index if not exists idx_complaints_created_at on public.complaints(created_at desc);
create index if not exists idx_complaints_department on public.complaints(assigned_department_id);
create index if not exists idx_complaints_location on public.complaints using gist(location);

-- Trigger to update updated_at timestamp
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = timezone('utc'::text, now());
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Drop trigger if exists, then create
DROP TRIGGER IF EXISTS update_complaints_updated_at ON public.complaints;
CREATE TRIGGER update_complaints_updated_at
  BEFORE UPDATE ON public.complaints
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

-- ============================================================================
-- SECTION 4: COMPLAINT ACTIONS TABLE (AUDIT LOG)
-- ============================================================================

create table if not exists public.complaint_actions (
  id bigint generated by default as identity primary key,
  complaint_id bigint references public.complaints on delete cascade not null,
  action_type public.action_type not null,
  action_description text not null,
  timestamp timestamp with time zone default timezone('utc'::text, now()) not null,
  metadata jsonb -- For storing additional context
);

alter table public.complaint_actions enable row level security;

-- Index for faster queries
create index if not exists idx_complaint_actions_complaint_id 
  on public.complaint_actions(complaint_id);
create index if not exists idx_complaint_actions_timestamp 
  on public.complaint_actions(timestamp desc);

-- ============================================================================
-- SECTION 5: FEEDBACK TABLE
-- ============================================================================

create table if not exists public.feedback (
  id bigint generated by default as identity primary key,
  complaint_id bigint references public.complaints on delete cascade not null,
  user_id uuid references auth.users on delete cascade not null,
  rating smallint check (rating >= 1 and rating <= 5),
  comment text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique (complaint_id, user_id) -- One feedback per user per complaint
);

alter table public.feedback enable row level security;

-- ============================================================================
-- SECTION 6: USER ROLES TABLE (RBAC)
-- ============================================================================

create table if not exists public.user_roles (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  role app_role not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique (user_id, role)
);

alter table public.user_roles enable row level security;

-- ============================================================================
-- SECTION 7: ROW LEVEL SECURITY POLICIES
-- ============================================================================

-- Departments policies (public read access)
DROP POLICY IF EXISTS "Anyone can view departments" ON public.departments;
CREATE POLICY "Anyone can view departments"
  ON public.departments FOR SELECT
  USING (true);

DROP POLICY IF EXISTS "Only admins can modify departments" ON public.departments;
CREATE POLICY "Only admins can modify departments"
  ON public.departments FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );

-- Complaints policies
DROP POLICY IF EXISTS "Users can view all complaints" ON public.complaints;
CREATE POLICY "Users can view all complaints"
  ON public.complaints FOR SELECT
  USING (true);

DROP POLICY IF EXISTS "Users can insert their own complaints" ON public.complaints;
CREATE POLICY "Users can insert their own complaints"
  ON public.complaints FOR INSERT
  WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update their own complaints" ON public.complaints;
CREATE POLICY "Users can update their own complaints"
  ON public.complaints FOR UPDATE
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Admins can update all complaints" ON public.complaints;
CREATE POLICY "Admins can update all complaints"
  ON public.complaints FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );

-- Complaint actions policies
DROP POLICY IF EXISTS "Anyone can view complaint actions" ON public.complaint_actions;
CREATE POLICY "Anyone can view complaint actions"
  ON public.complaint_actions FOR SELECT
  USING (true);

DROP POLICY IF EXISTS "System can insert complaint actions" ON public.complaint_actions;
CREATE POLICY "System can insert complaint actions"
  ON public.complaint_actions FOR INSERT
  WITH CHECK (true);

-- Feedback policies
DROP POLICY IF EXISTS "Users can view all feedback" ON public.feedback;
CREATE POLICY "Users can view all feedback"
  ON public.feedback FOR SELECT
  USING (true);

DROP POLICY IF EXISTS "Users can insert feedback for their own complaints" ON public.feedback;
CREATE POLICY "Users can insert feedback for their own complaints"
  ON public.feedback FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.complaints
      WHERE id = complaint_id AND user_id = auth.uid()
    )
  );

-- User roles policies
DROP POLICY IF EXISTS "Users can view their own roles" ON public.user_roles;
CREATE POLICY "Users can view their own roles"
  ON public.user_roles FOR SELECT
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Admins can view all roles" ON public.user_roles;
CREATE POLICY "Admins can view all roles"
  ON public.user_roles FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );

-- ============================================================================
-- SECTION 8: STORAGE BUCKET FOR COMPLAINT IMAGES
-- ============================================================================

-- Create storage bucket (safe - uses ON CONFLICT)
INSERT INTO storage.buckets (id, name, public)
VALUES ('complaint-images', 'complaint-images', true)
ON CONFLICT (id) DO NOTHING;

-- Storage policies (use separate storage_policies.sql file for non-destructive setup)
-- Or run these manually after bucket creation:
-- DROP POLICY IF EXISTS "Anyone can view complaint images" ON storage.objects;
-- CREATE POLICY "Anyone can view complaint images"
--   ON storage.objects FOR SELECT
--   USING (bucket_id = 'complaint-images');
-- 
-- DROP POLICY IF EXISTS "Authenticated users can upload complaint images" ON storage.objects;
-- CREATE POLICY "Authenticated users can upload complaint images"
--   ON storage.objects FOR INSERT
--   WITH CHECK (bucket_id = 'complaint-images' AND auth.role() = 'authenticated');

-- ============================================================================
-- SECTION 9: HELPER FUNCTIONS
-- ============================================================================

-- Function to get user role
create or replace function public.get_user_role(user_uuid uuid)
returns app_role as $$
  select role from public.user_roles
  where user_id = user_uuid
  limit 1;
$$ language sql security definer;

-- Function to check if user is admin
create or replace function public.is_admin(user_uuid uuid)
returns boolean as $$
  select exists (
    select 1 from public.user_roles
    where user_id = user_uuid and role = 'admin'
  );
$$ language sql security definer;

-- ============================================================================
-- SECTION 10: GRANT PERMISSIONS
-- ============================================================================

grant usage on schema public to anon, authenticated;
grant all on all tables in schema public to anon, authenticated;
grant all on all sequences in schema public to anon, authenticated;
grant all on all functions in schema public to anon, authenticated;

-- ============================================================================
-- SECTION 11: CREATE ADMIN USER (EXAMPLE)
-- ============================================================================

-- After creating a user through Supabase Auth, run this to make them admin:
-- Replace 'USER_UUID_HERE' with actual UUID from auth.users table

-- insert into public.user_roles (user_id, role)
-- values ('USER_UUID_HERE', 'admin');

-- ============================================================================
-- SCHEMA COMPLETE
-- ============================================================================